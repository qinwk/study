# 【品优购】项目技术点概述
项目背景
---
品优购是一个互联网电商类型网站,模式为时下流行的B2B2C，平台既有自营商品,并且允许第三方网站商家入驻，针对第三方商家信息和商品进行管理审核，通过平台和第三方商家的合作形式，提高网站的整体竞争力。

技术架构
---
AngularJS+SSM+Dubbo+Zokeeper+Solr+Redis+Mysql+MongoDB

技术描述
---
### Maven

使用Maven工具完成项目的管理和打包等,并对项目依赖的进行了规范化的管理。
### MavenProfile

使用MavenProfile实现**开发/生产**环境参数的**动态切换**。
### Dubbo+zookeeper

使用dubbo搭建分布式系统,使用zokeeper作为服务的注册中心，实现了项目的分离和服务远程调用。

<h5>Dubbo简介</h5>

Dubbox 致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理 方案。简单的说**，dubbox 就是个服务框架，如果没有分布式的需求，其实是不需要用的， 只有在分布式的时候，才有 dubbox 这样的分布式服务框架的需求，并且本质上是个服务调 用的东东，说白了就是个远程服务调用的分布式框架**

![](E:\面试资料\技术点图片\dubbox.PNG)

调用关系说明： 

0. 服务容器负责启动，加载，运行服务提供者。  
1. 服务提供者在启动时，向注册中心注册自己提供的服务。
2.  服务消费者在启动时，向注册中心订阅自己所需的服务。  
3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推 送变更数据给消费者。  
4.  服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，
   如果调用失败，再选另一台调用。 
5.  服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计 数据到监控中心。 

<h5>zookeeper简介</h5>

**官方推荐使用 zookeeper 注册中心。注册中心负责服务地址的注册与查找，相当于目 录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小**。

Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，**支持变更推送**，适 合作为 Dubbox 服务的注册中心，工业强度较高，可用于生产环境

变更推送：zookeeper独有的watch机制。[详情](https://www.jianshu.com/p/2d79ac04d2dc)

### AngularJS

使用AngularJS的实现异步请求,使用数据双向绑定机制完成页面数据的刷新。

<h5>AnglarJS简介</h5>

AngularJS 有着诸多特性，最为核心 的是：**MVC、模块化、自动化双向数据绑定、依赖注入**等等。 

**MVC**：.通过 依赖注入（dependency injection）鼓励展现，数据，和逻辑组件之间的松耦合。

Model:数据,其实就是 angular 变量($scope.XX); 
View:数据的呈现,Html+Directive(指令); 
Controller:操作数据,就是 function,数据的增删改查; 

![](E:\面试资料\技术点图片\MVC.PNG)

**双向绑定**：通过双向 的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。



![](E:\面试资料\技术点图片\双向绑定.PNG)

**依赖注入**：依赖注入(Dependency Injection,简称 DI)是一种设计模式, 指某个对象依赖的其他对象无 需手工创建，只需要“吼一嗓子”，则此对象在创建时，其依赖的对象由框架来自动创建并 注入进来,其实就是最少知识法则;模块中所有的 service 和 provider 两类对象，都可以根据形 参名称实现 DI.



高内聚低耦合法则 



### **SpringSecurity**（[day04](file:///E:/笔记/品优购_day04_课程讲义_V1.3.pdf)）

基于RBAC(Role-Base Access Controller)进行了权限模块的设计,在DB中存储了用户-角色-权限的基本数据,通过SpringSecurity实现系统的权限控制。

<h5>SpringSecurity简介</h5>

Spring Security 是一个能够为基于 Spring 的企业应用系统提供声明式的安全访问控制解 决方案的安全框架。**它提供了一组可以在 Spring 应用上下文中配置的 Bean，充分利用了 Spring IoC，DI（控制反转 Inversion of Control ,DI:Dependency Injection 依赖注入）和 AOP（面 向切面编程）功能，为应用系统提供声明式的安全访问控制功能**，减少了为企业系统安全控 制编写大量重复代码的工作

<h3>BCrypt加密算法（day04）</h3>

用户表的密码通常使用 MD5 等不可逆算法加密后存储，为防止彩虹表破解更会先使用一个特定的字符串（如域名）加密，然后再使用一个随机的 salt（盐值）加密。特定字符串 是程序代码中固定的，salt 是每个密码单独随机，一般给用户表加一个字段单独存储，比较 麻烦。BCrypt 算法将 salt 随机并混入最终加密后的密码，**验证时也无需单独提供之前的 salt， 从而无需单独处理 salt 问题。** 

### Fastdfs([day05](file:///E:/笔记/品优购_day05_课程讲义_V1.3.pdf))

使用FastDFS分布式文件系统,实现系统海量文件的分布式存储，提高了系统文件管理的独立性。

<h5>FastDFS简介</h5>

FastDFS 是用 **c 语言编写**的一款**开源的分布式文件系统**。FastDFS 为互联网量身定制， 充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标**，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务**。 
FastDFS 架构包括 **Tracker server** 和 **Storage server**。客户端请求 Tracker server 进行文 件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。 
Tracker server 作用是**负载均衡和调度**，通过 Tracker server 在文件上传时可以根据一些 策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。

Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上， Storage server 没有实现自己的文件系统而是利用操作系统的文件系统来管理文件。可以将 storage 称为**存储服务器**

![](E:\面试资料\技术点图片\FastDFS.PNG)

服务端两个角色： 
	**Tracke**r：管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。 
	**Storage**：实际保存文件   Storage 分为多个组，每个组之间保存的文件是不同的。每 个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有 主从的概念

![](E:\面试资料\技术点图片\文件上传.png)

![](E:\面试资料\技术点图片\文件下载.png)



### Redis（[day08](file:///E:/笔记/品优购_day08_课程讲义_V1.3.pdf)）

使用Redis缓存系统的高频数据（广告信息/商品分类/模板/规格等信息/秒杀商品和订单）,提高了数据的加载速度,并缓解了数据库访问的压力。

<h5>redis使用前提</h5>

是对于首页每天有大量的人访问，对数据库造成很大的访问压力，甚至是瘫痪。那如何解决呢？我们通常的做法有两 种：

一种是**数据缓存**、一种是**网页静态化**。

<h5>redis简介</h5>

> **Redis** 
>
> redis 是一款开源的 Key-Value 数据库，运行在内存中，由 ANSI C 编写。企业开发通常 采用 Redis 来实现缓存。同类的产品还有 memcache 、memcached 、**MongoDB** 等。
> **Jedis**
>
> Jedis 是 Redis 官方推出的一款面向 Java 的客户端，提供了很多接口供 Java 语言调用。 可以在 Redis 官网下载，当然还有一些开源爱好者提供的客户端，如 Jredis、SRP 等等，推荐 使用 Jedis

<h5>Spring-Data-Redis简介</h5>

Spring-data-redis 是 spring 大家族的一部分，提供了在 srping 应用中通过简单的配置访 问 redis 服务，对 reids 底层开发包(Jedis,  JRedis, and RJC)进行了高度封装，**RedisTemplate** 提 供了 redis 各种操作、异常处理及序列化，支持发布订阅，并对 spring 3.1 cache 进行了实现。

spring-data-redis 针对 jedis 提供了如下功能：

 1.连接池自动管理，提供了一个高度封装的“**RedisTemplate**”类 

 2.针对 jedis 客户端中大量 api 进行了归类封装,将同一类型操作封装为 operation 接口  

ValueOperations：简单 K-V 操作  

SetOperations：set 类型数据操作  

ZSetOperations：zset 类型数据操作  

HashOperations：针对 map 类型的数据操作 

 ListOperations：针对 list 类型的数据操作 

### Solr（[day09](file:///E:/笔记/品优购_day09_课程讲义_V1.3.pdf)）

在Solr搜索服务器建立商品信息的索引库,实现商品的多样化搜索,并有效提高了商品搜索的效率和准确性。

<h5>Solr简介</h5>

Solr 是一个开源搜索平台，用于构建搜索应用程序。 它建立在 **Lucene**(全文搜索引擎) 之上。 Solr 是企业级的，快速的和高度可扩展的。 使用 Solr 构建的应用程序非常复杂，可 提供高性能。

Solr 可以和 **Hadoop** 一起使用。**由Hadoop 处理大量数据，Solr 帮助我们从这么大的源 中找到所需的信息**。不仅限于搜索，Solr **也可以用于存储目的**。像其他 NoSQL 数据库一样， 它是一种**非关系数据存储和处理技术**

总之，Solr 是一个可扩展的，可部署，搜索/存储引擎，**优化搜索大量以文本为中心的 数据**。



<h5>中文分析器 IK Analyzer简介</h5>

IK Analyzer 是一个开源的，基亍 **java 语言开发**的轻量级的中文**分词**工具包。从 2006 年 12 月推出 1.0 版开始， IKAnalyzer 已经推出了 4 个大版本。最初，它是以开源项目 **Luence** 为应用主体的，结合词典分词和文法分析算法的中文分词组件。从 3.0 版本开始， IK 发展为面向 **Java 的公用分词组件，独立亍 Lucene 项目，同时提供了对 Lucene 的默认 优化实现**。在 2012 版本中，IK 实现了简单的分词歧义排除算法，标志着 IK 分词器从单 纯的词典分词向模拟语义分词衍化

**Spring Data Solr** 就是为了方便 Solr 的开发所研制的一个 **框架**，其底层是对 **SolrJ**（官方 API）的**封装**

**solrTemplate.commit();** <font color='red'>得提交才能生效</font>



引入 fastJSON 依赖 

```
//将 spec 字段中的 json 字符串转换为 map 
Map specMap= JSON.parseObject(item.getSpec());
//动态域给带注解的字段赋值 
   item.setSpecMap(specMap);
```

[**solr关键字高亮显示的使用**](https://my.oschina.net/u/3963165/blog/2051183)

### [FreeMarker day12](file:///E:/笔记/品优购_day12_课程讲义_V1.3.pdf)

使用FreeMarker技术进行商品详情页静态化处理,提高了页面的访问速度,减少了数据库的访问压力。

<h5>为什么要是用网页静态化技术</h5>

网页静态化技术和缓存技术的共同点都是**为了减轻数据库的访问压力**，但是具体的应用场景不同，**缓存比较适合小规模的数据**，**而网页静态化比较适合大规模且相对变化不太频繁 的数据**。另外网页静态化还有利于 SEO。 
另外我们如果将网页以**纯静态化的形式展现，就可以使用 Nginx 这样的高性能的 web 服务器来部署**。Nginx 可以承载 5 万的并发，而 Tomcat 只有几百。



<h5>FreeMarker简介</h5>

FreeMarker 是一个用 **Java 语言编写**的模板引擎，它基于**模板来生成文本输出**。 **FreeMarker 与 Web 容器无关**，即在 Web 运行时，它并不知道 Servlet 或 HTTP。它不仅 可以用作表现层的实现技术，而且还可以用于生成 XML，JSP 或 Java 等.

<h5>模板文件中四种元素</h5> 
 1、文本，直接输出的部分 

 2、注释，即<#--...-->格式不会输出   

 3、插值（Interpolation）：即${..}部分,将使用数据模型中的部分替代输 

 4、FTL 指令：FreeMarker 指令，和 HTML 标记类似，名字前加#予以区分，不会输出。

### [ActiveMQ day13](file:///E:/笔记/品优购_day13_课程讲义_V1.3.pdf) 

使用ActiveMQ实现系统间的解耦,提高了系统的扩展性和服务器的响应速度。

<h5>消息中间件 简介</h5>

消息中间件利用高效可靠的**消息传递机制**进行**平台无关**的数据交流，并**基于数据通信来进行分布式系统的集成**。通过提供**消息传递**和**消息排队**模型，它可以在分布式环境下扩展进 程间的通信。对于消息中间件，常见的角色大致也就有 Producer（生产者）、Consumer（消 费者） 
常见的消息中间件产品: 
（1）**ActiveMQ** 
ActiveMQ 是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完 全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现。我们在本次课程中介绍 ActiveMQ 的使 用。 
（2）RabbitMQ 
AMQP 协议的领导实现，支持多种场景。淘宝的 MySQL 集群内部有使用它进行通讯， OpenStack 开源云平台的通信组件，最先在金融行业得到运用。 
（3）ZeroMQ 
史上最快的消息队列系统 
（4）Kafka 
Apache 下的一个子项目 。特点：高吞吐，在一台普通的服务器上既可以达到 10W/s 的吞吐速率；完全的分布式系统。适合处理海量数据。 

**解耦关系图**

![](E:\面试资料\技术点图片\ActiveMQ解耦.PNG)



<h5>JMS简介</h5>

JMS（Java Messaging Service）是 **Java 平台上**有关**面向消息中间件**的技术**规范**，它便 于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的 接口简化企业应用的开发。 
       JMS 使您能够通过消息收发服务（有时称为消息中介程序或 路由器）从一个 JMS 客户机向另一个 JML 客户机发送消息。消息是 JMS 中的一种类型对 象，由两部分组成：**报头**和**消息主体**。**报头由路由信息以及有关该消息的元数据组成**。**消息 主体则携带着应用程序的数据或有效负载**

JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收些不同形式的数据，提供现有消息格式的一些级别的兼容性。 
· **TextMessage**--一个字符串对象 
· **MapMessage**--一套名称-值对 
· ObjectMessage--一个序列化的 Java 对象 
· BytesMessage--一个字节的数据流 
· StreamMessage -- Java 原始值的数据流

![一种是点对点的，即一个生产者和一个消费者一一对应](E:\面试资料\技术点图片\点对点.PNG)

**点对点**的模式主要建立在一个队列上面，当连接一个列队的时候，发送端不需要知道接 收端是否正在接收，可以直接向 ActiveMQ 发送消息，发送的消息，将会先进入队列中，如 果有接收端在监听，则会发向接收端，如果没有接收端接收，则会保存在 activemq 服务器， 直到接收端接收消息，点对点的消息模式可以有多个发送端，多个接收端，但是一条消息， 只会被一个接收端给接收到，哪个接收端先连上 ActiveMQ，则会先接收到，而后来的接收 端则接收不到那条消息

![发布/ 订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进 
行接收](E:\面试资料\技术点图片\订阅发布.PNG)

### [SpringBoot day14](file:///E:/笔记/品优购_day14_课程讲义_V1.3.pdf)

使用SpringBoot搭建独立的**微服务**短信系统,并集成阿里大于的云短信接口实现系统短信发送功能。

### [CAS day15](file:///E:/笔记/品优购_day15_课程讲义_V1.3.pdf)

使用CAS技术实现分布式系统之间单点登录功能，并且与SpringSecurity框架整合实现单点登录和权限控制。

<h5>什么是单点登陆</h5>

单点登录（Single Sign On），简称为 SSO。SSO 的定义是在**多个应用系统**中，用户**只需要登录一次**就可以访问所有相互信任的应 用系统。 
我们目前的系统存在诸多子系统，而这些子系统是分别部署在**不同的服务器**中，那么使 用传统方式的 **session 是无法解决**的，我们需要使用相关的**单点登录技术来解决**

![](E:\面试资料\技术点图片\单点登陆.PNG)

<h5>CAS简介</h5>

CAS 具有以下特点： 
【1】开源的企业级单点登录解决方案。 
【2】CAS Server 需要**独立部署**的 Web 应用。 
【3】CAS Client **支持非常多的客户端**(这里指单点登录系统中的各个 Web 应用)，包括 Java, .Net, PHP, Perl, Apache, uPortal, Ruby 等。 

从结构上看，CAS 包含两个部分： **CAS Server** 和 **CAS Client**。CAS Server 需要**独立部署**， 主要负责对**用户的认证**工作；CAS Client 负责处理对客户端受**保护资源**的访问请求，需要登 录时，重定向到 CAS Server

CAS 最基本的协议过程：

![](E:\面试资料\技术点图片\CAS基本协议.PNG)

SSO 单点登录访问流程主要有以下步骤： 
1. 访问服务：SSO 客户端发送请求访问应用系统提供的服务资源。 

2. 定向认证：SSO 客户端会重定向用户请求到 SSO 服务器。 

3. 用户认证：用户身份认证。 

4. 发放票据：SSO 服务器会产生一个随机的 Service Ticket。

5. 验证票据：SSO 服务器验证票据 Service Ticket 的合法性，验证通过后，允许客户端访问 服务。 

6. 传输用户信息：SSO 服务器验证票据通过后，传输用户认证结果信息给客户端。 

   **整体思路和TCP三次握手相似**

### **[购物车逻辑 day16](file:///E:/笔记/品优购_day16_课程讲义_V1.3.pdf)**

当用户在**未登录**的情况下，将此购物车存入 **cookies** , 在**用户登陆**的情况下，将购物车 数据存入 **redis**  。如果用户登陆时，cookies 中存在购物车，需要将 cookies 的**购物车合并** 到 **redis 中存储**. 

![](E:\面试资料\技术点图片\购物车.PNG)



**实现思路**

//1.根据商品 SKU ID 查询 SKU 商品信息 
  //2.获取商家 ID   
  //3.根据商家 ID 判断购物车列表中是否存在该商家的购物车   
  //4.如果购物车列表中不存在该商家的购物车 
  //4.1 新建购物车对象 
  //4.2 将新建的购物车对象添加到购物车列表 

//5.如果购物车列表中存在该商家的购物车   
  // 查询购物车明细列表中是否存在该商品 
  //5.1. 如果没有，新增购物车明细   
  //5.2. 如果有，在原购物车明细上添加数量，更改金额 

### [SpringMVC跨域 day17](file:///E:/笔记/品优购_day17_课程讲义_V1.3.pdf)

基于SpringMVC实现CORS式的跨域请求,解决了分布式系统间JS的跨域请求问题。

<h5>跨域请求的两种解决方法</h5>

1、**jsonp**：通过服务端response返回script标签，来设置请求跨域heard；

2、**CORS**：直接response跨域请求头。

<h5>跨域请求解决方案CORS</h5>

它**允许浏览器向跨源服务器**，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源 使用的限制。整个 CORS 通信过程，都是**浏览器自动完成**，不需要用户参与。对于开发者来 说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨 源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的**关键是服务器**。**只要服务器实现了 CORS 接口，就可以跨源通信**

![](E:\面试资料\技术点图片\跨域请求.PNG)

CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服 务器同意，指定 **Access-Control-Allow-Credentials** 字段。另一方面，开发者必须在 AJAX 请求 中打开 **withCredentials** 属性。否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者， 服务器要求设置 Cookie，浏览器也不会处理

@CrossOrigin(origins="http://localhost:9105",allowCredentials="true") 

### 雪花算法

<h5>分布式ID生成器</h5>

![](E:\面试资料\技术点图片\雪花算法.PNG)



### [微信扫码支付 day18](file:///E:/笔记/品优购_day18_课程讲义_V1.3.pdf)

集成微信扫码支付SDK,实现订单支付功能。

<h5>二维码简介</h5>

二维码又称 **QR Code**，QR 全称 Quick Response，是一个近几年来移动设备上超流行的一 种编码方式，它比传统的 **Bar Code** 条形码能存更多的信息，也能表示更多的数据类型。 
二维条码/二维码（2-dimensional bar code）是用某种**特定的几何图**形按一定**规律**在平面 （**二维方向上**）分布的**黑白相间**的图形**记录数据符号信息**的；在代码编制上巧妙地利用构成 计算机内部逻辑基础的**“0”、“1”比特流**的概念，使用若干个与**二进制相对应的几何形**体来表 示**文字数值信息**，通过图象输入设备或光电扫描设备自动识读以**实现信息自动处理**：

它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的 校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。

<h5>二维码优势</h5>

 **信息容量大**, 可以容纳多达 1850 个大写字母或 2710 个数字或 500 多个汉字 
 **应用范围广**, 支持文字,声音,图片,指纹等等... 
 **容错能力强**, 即使图片出现部分破损也能使用 
 **成本低,** 容易制作 

<h5>二维码容错级别</h5>

L 级（**低**） 7％的码字可以被恢复。 
M 级（**中**） 的码字的 15％可以被恢复。 
Q 级（**四分**）的码字的 25％可以被恢复。 
H 级（**高**） 的码字的 30％可以被恢复

二维码生成插件 **qrious** 

<h5>微信支付实现思路</h5>

我们通过 HttpClient 工具类实现对远程支付接口的调用。 
接口链接：https://api.mch.weixin.qq.com/pay/orderquery 
具体参数参见“查询订单”API, 我们在 controller 方法中**轮询调用**查询订单（间隔 3 秒）， 当返回状态为 success 时，我们会在 controller 方法返回结果。前端代码收到结果后跳转到成 功页面。

如果用户到了二维码页面**一直未支付**，或是**关掉了支付页面**，我们的代码会一直循环调用微信接口，这样会对程序造成很大的压力。所以我们要**加一个时间限制**或是**循环次数限制**， 当**超过时间或次数**时，**跳出循环**

### 支付日志

<h5>需解决问题</h5>

（1）系统中**无法查询到支付记录** 
（2）支付后订单**状态没有改变** 

<h5>实现思路</h5>

（1）在**用户下订单**时，判断如果为微信支付，就想支付日志表添加一条记录，信息包括支 付总金额、订单 ID（多个）、用户 ID 、下单时间等信息，支付状态为 0（未支付） 
（2）生成的**支付日志**对象放入 **redis** 中，以**用户 ID 作为 key**，这样在**生成支付二维码时**就可 以从 **redis 中提取支付日志对象**中的**金额**和**订单号**。 
（3）当用户**支付成功**后，修改**支付日志**的支付**状态为 1**（已支付），并记录微信传递给我 们的**交易流水号**。根据**订单 ID**（多个）修改订单的**状态为 2（**已付款）。**清除缓存**中的支付日志对象 

### [SpringTask day19](file:///E:/笔记/品优购_day19_课程讲义_V1.3.pdf)

使用SpringTask实现**定时任务**(**缓存数据的同步**,**sol**r服务器的数据**更新**和秒杀商品的**增量更新**和过期**商品的移除**)的处理。

<h5>秒杀需求</h5>

秒杀商品通常有两种限制：**库存限制**、**时间限制**

需求： 
（1）商家**提交秒杀商品申请**，**录入**秒杀商品数据，主要包括：商品标题、原价、秒杀 价、商品图片、介绍等信息 
（2）运营商**审核**秒杀申请 
（3）秒杀频道**首页列出**秒杀商品（进行中的）**点击**秒杀商品图片**跳转到秒杀商品详细 页**。 
（4）商品**详细页显示**秒杀商品信息，点击**立即抢购**实现秒杀下单，**下单时扣减库存**。 当**库存为 0** 或**不在活动期范围内**时**无法秒杀**。 
（5）秒杀**下单成功**，直接跳转到**支付页面**（微信扫码），**支付成功**，跳转到**成功页**， **填写**收货地址、电话、收件人等**信息**，**完成订单**。 
（6）当用户秒杀下单 **5 分钟内未支付**，**取消预订单**，调用**微信支付的关闭**订单接口， **恢复库存**。 

<h5>秒杀实现思路</h5>

秒杀技术实现核心思想是**运用缓存**减少数据库瞬间的**访问压力**！**读取**商品**详细信息时**运 用**缓存**，当用户点击**抢购**时**减少缓存**中的**库存数量**，当库存数为 0 时或活动期结束时，**同步** 到**数据库**。 产生的**秒杀预订单**也不会立刻写到数据库中，而是**先写到缓存**，当用户**付款成 功**后再**写入数据库**

<h5>SpringTask简介</h5>

，即在某个时间点做某件事情，核心是以 时间为关注点，即在一个特定的时间点，系统执行指定的一个操作。常见的任务调度框架有 Quartz 和 SpringTask 等

@Scheduled(cron="0 * * * * ?")

**每分钟**执行查询秒杀商品表，将符合条件的记录并且缓存中不存在的秒杀商品存入缓存

@Scheduled(cron="* * * * * ?")  

**每秒**中在缓存的秒杀上皮列表中查询过期的商品，发现过期同步到数据库，并在缓存中移除 该秒杀商

### [MongoDB day20](file:///E:/笔记/品优购_day20_课程讲义_V1.3.pdf)

使用MongoDB数据库缓存商品评论信息和收藏商品信息,提高了大批量数据的快速存储和访问。

